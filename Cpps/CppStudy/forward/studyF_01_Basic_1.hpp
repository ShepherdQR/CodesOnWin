/* ===========
//  * Author: Shepherd Qirong
//  * Date: 2022-07-10 22:08:32
//  * Github: https://github.com/ShepherdQR
//  * LastEditors: Shepherd Qirong
//  * LastEditTime: 2022-09-03 21:16:39
//  * Copyright (c) 2019--20xx Shepherd Qirong. All rights reserved.
*/
#pragma once

#include<iostream>
#include<type_traits>
#include<memory>
#include<vector>
#include<array>
#include<string>
//#import <algorithm>//error: #import of type library is an unsupported Microsoft feature
#include<functional>
#include<algorithm>
#include<set>
#include<bitset>
#include<mutex>
#include<thread>
#include<numeric>

#include <iomanip>
#include<cmath>
#include<numbers>
#include<regex>
//#include<cstdint>


//clang -std=c++2b
//230
namespace Basic{

    // 隐式类型转换：高等级->低等级，有符号->无符号。



    using namespace std;

    auto func_999(){
        //[final] forbids the decorated class or member funciton from being inherited or voerloaded.
        // [=default, =delete] decorates the A(),~A(), operator=, A(A&), etc.
        // enum class A: unsigned int{};

        // std::terminate() 

        /* ===========
        lvalue, the value left to the assignment symbol.
        rvalue, right to the assignment symbol, dies after the expression ends.
        pvalue, pure rvalue. like 2, ture, 1+2, temporary variables generated by operation expressions, original literals, and Lambda expressions.
        xvalue, expiring value, such as the returned object of a function, can be moved using std::move.

        reference collapsing rule: only T is r, then only T&& is r too.
        */

       /* ===========
        regular expression

        $       match end

        (,)     marks the start and end of a subexpression

        *       matches the previous subexpression 0 or more times.     [For example, foo* matches fo and foooo. * is equivalent to {0,}.]
        
        +       matches the previous subexpression 1 or more times       [For example, foo+ matches foo and foooo but does not match fo. + is equivalent to {1,}.]  

        .       matches any single character except the new line \n
        [       the beginning of a bracket expresion.
        
        ?       matches the previous subexpression 1 or more times, or indicates a non-greedy qualifier.        [For example, Your(s)? can match Your in Your or Yours. ? is equivalent to {0,1}.]

        \       Marks the next character as either a special character, or a literal character, or a backward reference, or an octal escape character. For example, n Matches the character n. \n matches newline characters. The sequence \\ Matches the '\' character, while \( matches the '(' character.
        ^       Matches the beginning of the input string, unless it is used in a square bracket expression, at which point it indicates that the set of characters is not accepted.
        {       the beginning of a qualifier expression.
        \|      Indicates a choice between the two.
        {n}     n is a non-negative integer. Matches the determined n times. For example, o{2} cannot match o in for, but can match two o in foo.
        {n,}    n is a non-negative integer. Match at least n times. For example, o{2,} cannot match o, but matches all o in foooooo. o{1,} is equivalent to o+. o{0,} is equivalent to o*.
        {n,m}   m and n are non-negative integers, where n is less than or equal to m. Matches at least n times and matches up to m times. For example, o{1,3} will match the first three o in foooooo. o{0,1} is equivalent to o?. Note that there can be no spaces between the comma and the two numbers.

       */




    }

    auto func_35(){

       std::string str[]{"foo.txt", "bar.txt", "a1.txt", "AA.txt", "ab.tex"};
       std::regex my_regex("[a-z]+\\.txt");
       std::smatch base_match;
       for(const auto& cur: str){
            std::cout << cur << "\t\t" << std::regex_match(cur, my_regex) << std::endl;//11000

            if(std::regex_match(cur, base_match, my_regex)){
                auto sz{base_match.size()};
                std::cout << sz << std::endl;
                if(sz==1){
                    std::string base = base_match[1].str();
                    std::cout << "[0, 1]\t" << base_match[0].str() << ", " << base << std::endl;
                }
            }
       }
        /********************************
            foo.txt         1
            1
            [0, 1]  foo.txt,
            bar.txt         1
            1
            [0, 1]  bar.txt,
            a1.txt          0
            AA.txt          0
            ab.tex          0
       */
    }





    auto func_34(){
        
        auto p = std::make_unique<int>(11);
        auto _1 = [&p][[nodiscard]]->int&{
            //int pa = *p;// warning: ignoring return value of ‘Basic::func_34()::<lambda()>’, declared with attribute ‘nodiscard’ [-Wunused-result]
            static int pa = *p;
            return pa;
        }();

        auto _2 = /***/(std::move([&p][[nodiscard]]->int* /*&*/{
            //int pa = *p;// warning: ignoring return value of ‘Basic::func_34()::<lambda()>’, declared with attribute ‘nodiscard’ [-Wunused-result]
            auto p1 = p.get();
            return p1;
        }()));




        printf("%d\n", *p);

    }

    auto func_33(){

        struct A{
            A(char ic):_ic(ic){}
            char _ic{'_'};
            virtual ~A(){printf("\t%c\n", _ic);}
        };

        struct B2;
        struct B1 : A{
            using A::A;
            std::shared_ptr<B2> sp{nullptr};
        };
        struct B2 : A{
            using A::A;
            std::weak_ptr<B1> wp;
        };


        // set sp to wp frist, or last, dose not matter
        {
            auto sp1 = std::make_shared<B1>('1');
            auto sp2 = std::make_shared<B2>('2');
            sp2->wp = sp1;
            sp1->sp = sp2;
        }// 2 1

        {
            auto sp1 = std::make_shared<B1>('1');
            auto sp2 = std::make_shared<B2>('2');
            sp1->sp = sp2;
            sp2->wp = sp1;
        }// 2 1


    }

    auto func_32(){
        
        printf("unique_ptr\n");


        {
            struct AA{
                int aa{11};
            };

            struct MyDeletor{
                void operator()(AA *pt) const{
                    if (pt){
                        printf("hi\n");
                        delete pt;
                        pt = nullptr;
                    }
                }
            };

            std::unique_ptr<AA,MyDeletor> p1(new AA(22), MyDeletor());
            std::cout << p1->aa << std::endl;
            
        }

        {
            // auto lDeletor = [](int* ip) {
            //     if (ip){
            //         printf("hi\n");
            //         delete ip;
            //         ip = nullptr;
            //     }
            // };

            // std::unique_ptr<int,lDeletor> p1(new int(22), lDeletor());
            // std::cout << *p1 << std::endl;
           
        }

        {
            
            if( struct A{
                    void f(int i){
                        printf("\tF%d\n", i);
                    }
                };
                auto p1{std::make_unique<A>()})
            {
                p1->f(1);//  F1

                auto l = [&p1, p2{std::move(p1)}]mutable {
                    puts("hello\n");
                    if(p1){
                        p1->f(11);
                        p2 = std::move(p1);
                    }
                    else if(p2){
                        p2->f(22);
                        p1 = std::move(p2);
                    }
                };
                l();//  F22
                l();//  F11
            }
        }


    }

    auto func_31(){

        // shared_ptr
        {
            printf("shared_ptr\n");
            auto p1 = std::make_shared<int>(11);
            std::cout << p1.use_count() << std::endl;//1
            auto p2 = p1;
            std::cout << p2.use_count() << std::endl;//2

            p2.reset();
            std::cout << p1.use_count() << std::endl;//1
            std::cout << p2.use_count() << std::endl;//0

            //std::cout << *p2 << std::endl;//crush
            p2.reset();

            p1.reset();
            std::cout << p1.use_count() << std::endl;//0

        }

    }



    auto func_30(){

        std::string str{"hi"};

        auto l = [](auto&& istr){ 
            std::string str{"11"};
            std::string st2{"1111"};
            str = std::move(istr);
            puts(str.c_str());//output is istr
            puts(istr.c_str());//output is str
        };
        l(str);// hi; 11
        puts(str.c_str());//11

        std::string&& rrstr{[]{return std::string{"aa"};}()};
        l(rrstr);// aa; 11
        puts(rrstr.c_str());//11






        struct A{
            int _{0};
        };
        A a1{1};
        [](auto&& iA){ 
            A a2{2};
            a2 = std::move(iA);
            printf("%d\n",a2._);//1
        }(a1);
        printf("%d\n",a1._);//1


    }

    auto func_29_1(std::string& is){
        puts("L");
    }
    auto func_29_1(std::string&& is){
        puts("R");
    }
    auto func_29_1(int& is){
        puts("L int");
    }
    auto func_29_1(int&& is){
        puts("R int");
    }


    // error, no match for l1, "hi", n1
    // template<typename T>
    // constexpr T&& func_29_3_Forward(typename std::remove_reference<T>::type& t)noexcept{
    //     return static_cast<T&&>(t);
    // }
    // template<typename T>
    // constexpr T&& func_29_3_Forward(typename std::remove_reference<T>::type&& t)noexcept{
    //     static_assert(!std::is_lvalue_reference<T>::value, "T is LRef.");
    //     return static_cast<T&&>(t);
    // }

    template<typename T>
    auto func_29_2(T&& t){
        puts(__func__);
        func_29_1(t);//string: L for variable, R for literal; int: L always
        func_29_1(std::move(t));//[string, int]: R always
        func_29_1(std::forward<T>(t));//[string, int]: L for variable, R for literal
        func_29_1(static_cast<T&&>(t));//[string, int]: L for variable, R for literal
        //func_29_1(func_29_3_Forward(t));//error
    }
    auto func_29(){
        std::string l1 = "hi";
        std::string& l1R = l1;
        std::string&& l2_FromL2R = std::move(l1);// move l to r

        const std::string& l3 = l1 + l2_FromL2R;
        std::cout << l3 << std::endl;//hihi

        std::string&& l4 = l1 + l3;
        std::cout << l4 << std::endl;//hihihi

        func_29_1(l1);//L
        func_29_1(l2_FromL2R);//L
        func_29_1(const_cast<std::string&>(l3));//L
        func_29_1(l4);//L
        func_29_1({});//R

        puts("Lambda1");
        auto lambda1 = [](auto&& t){
            func_29_1(t);
        };
        lambda1(l1);//L
        lambda1("hi");//R

        puts("Lambda2");
        auto lambda2 = []<typename T>(T&& t){
            func_29_1(t);
        };
        lambda2(l1);//L
        lambda2("hi");//R

        func_29_2(l1);//L, std::basic_string<char>&
        func_29_2(l1R);//L
        func_29_2(l4);//L
        func_29_2("hi");//R, const char [3]

        int nnn = 1;
        //int n = nnn;// same result as n = 1
        int n = 1;
        int& n_l = n;
        int&& n_r= std::move(n_l);;
        func_29_2(n);//L
        func_29_2(n_l);//L
        func_29_2(n_r);//L
        func_29_2(1);//R

    }



    auto func_28(){
        using f1 = void(char);
        [](f1 f){
            f('a');
        }([](char a){
            puts(&a);
        });//a
    }


    auto func_27(){

        // use mutable, the value of v1 is remembered via each call.
        auto l = [ v1 = 1]()mutable{
            ++v1;
            printf("%d",v1);
        };

        l();//2
        l();//3
    }

    
    auto func_26(){
        enum class A : int{
        //enum class A : bool{// error: enumerator value ‘2’ is outside the range of underlying type ‘bool’
            a1, a2, a3, a4, a5
        };

        using enum A;
        cout << static_cast<int>(a1) << endl;
        cout << static_cast<int>(a3) << endl;
    }

    class BitParrern{
    public:
        std::uint64_t expected{};
        std::uint64_t mask{0xFFFFFFFFFFFFFFFF};
    private:
        template<std::size_t Size>
        explicit constexpr BitParrern(const char (&input)[Size]){
            std::uint64_t curBit = (1<< (Size -2));
            for(const char val :input){
                if(val == 0){
                    return;
                }

                if(val == '1'){
                    expected |= curBit;
                }else if (val == '0'){

                }else if (val == 'x'){
                    mask &= -curBit;
                }else{
                    throw std::logic_error("Invalid.");
                }
                curBit >>=1;
            }
        }
    };

    
    auto func_25(){

        //static_assert(0b1101010 == BitParrern("11xxx10"));

    }

    auto func_24(){
        std::vector<int> vec{0, 1,2,3,4,5};
        //auto val = vec[2,[]{}(),3];//top-level comma expression in array subscript is deprecated
        //cout << val << endl;//3
    }

    auto func_23(){
        const long double pi = std::acos(-1.L);
        std::cout << std::setprecision(30) << pi << std::endl;
        std::cout << std::setprecision(30) << 
        std::numbers::pi_v<long double> << std::endl;

    }

    auto func_22(){
        const int a[]{1,2,3};
        /*const auto a1 =*/ std::to_array(a);
        /*const std::array<int, 3> a3 = */std::to_array(a);

        //const auto str = "hi";
        //const auto b1 = std::to_array(str);//error: no matching function for call to ‘to_array(const char* const&)’
        /*const auto b2 = */std::to_array("hi");
    }

    auto func_21(){
        cout << std::bitset<32>(3).count() << endl;//2
        cout << std::popcount(3u) << endl;//2
        cout << std::midpoint(std::numeric_limits<int>::max(),
        (std::numeric_limits<int>::max()-3)) << endl;
    }


    //Delegate constructor
    // Inheritance constructor
    auto func_20(){

        // constructor a1 has n1 parameters, a2 has n2, a1:a2 or a2:a1
        struct A{
            int _1{},_2{};
            A():_1{1}{}
            //A(int i):A(),_2{i}{}//error: mem-initializer for ‘Basic::func_20()::A::_2’ follows constructor delegation
            A(int i):A(){_2 = i;}
            
        } _{11};
        std::cout << _._1 << ", " << _._2 << std::endl;//1, 11

        struct B{
            B():B(0){puts("b");}
            B(int):B(){puts("b_");}
        }; //B _b;// recursion, no output, stackOverflow.

        struct C:public A{
            using A::A;
        } _c{11};
        std::cout << _c._1 << ", " << _c._2 << std::endl;//1, 11

    }



    auto func_19_1(){
    }
    auto func_19_2(std::stop_token st){
        puts("starts");
        while(!st.stop_requested()){
            puts("working");
        }
        puts("stop.");
    }
    auto func_19(){
        // 1. jthread can automatically stop.
        // 2. std::stop_token

        std::thread t1{func_19_1};
        //without join, aborted. terminate called without an active exception
        t1.join();

        std::jthread t2{func_19_1};//automatically join
        // it automatically calls : 
        //.request_stop();
        //t2.join();

        std::jthread t3{func_19_2};
        for(int i = 0; i <55;++i){
            std::this_thread::yield();
            std::this_thread::yield();
            std::this_thread::yield();
        }
        /* ===========
            Hi<
            starts
            working
            working
            working
            working
            stop.

            >Bye.
        */
    }

    auto func_18(){
        //[[nodiscard]]
        
        struct S{
            [[nodiscard]] S(int){}
        };
        //S{1};//warning: ignoring return value of ‘Basic::func_18()::S::S(int)’, declared with attribute ‘nodiscard’ [-Wunused-result]
        
        struct [[nodiscard]] S1{
        };

        []{return S{{}};}();// no warning
        //[]{return S1{};}();// warning: ignoring returned value of type ‘Basic::func_18()::S1’, declared with attribute ‘nodiscard’ [-Wunused-result]

        struct [[nodiscard("The value should be catched!")]] S3{
        } _;
        //[]{return S3{};}();// warning: ignoring returned value of type ‘Basic::func_18()::S3’, declared with attribute ‘nodiscard’: ‘The value should be catched!’ [-Wunused-result]

        //auto aa = []{return S3{};}();// warning: variable ‘aa’ set but not used [-Wunused-but-set-variable]

        // the returned value should be catched, or casted to void, or the compiler displays an error.
        // when one function returns S3* or S3&, and the returned value is not caught, no error occurs.

    }   




    constexpr int func_17_1(){
        return 20220719;
    }
    int& func_17_2(){
        static auto val =  func_17_1();
        return val;
    }  
    int& func_17_3(){
        // val is initialized at compile time
        constinit static auto val =  func_17_1();
        return ++val;
    }

    const int& func_17_4(){
        // val is initialized at compile time
        const constinit static auto val =  func_17_1();
        return val;
    }
    const int& func_17_5(){
        // compile time initialized static mutex,
        // we hava a global mutable thread safe locked protected value.
        //constinit static std::mutex my_mutex;
        //std::scoped_lock l(my_mutex);  
        constinit static auto val =  func_17_1();
        ++val;
        return val;
    }

    auto func_17(){
        int& i = func_17_2();cout << i << endl;//20220719
        int& i3 = func_17_3();cout << i3 << endl;//20220720
        const int& i4 = func_17_4();cout << i4 << endl;//20220719
        const int& i5 = func_17_5();cout << i5 << endl;//20220720

    }




    template<typename T, 
        typename = std::enable_if_t<std::is_floating_point_v<T>>>
    auto func_16_1(const T t1, const T t2){
        return t1+t2;
    }

    template<typename T>
    auto func_16_2(const T t1, const T t2) requires std::is_floating_point_v<T>{
        return t1+t2;
    }

    template<typename T>
    concept T_floating_point = std::is_floating_point_v<T>;
    template< T_floating_point T>
    auto func_16_3(const T t1, const T t2){
        return t1+t2;
    }
    
    auto func_16_4(const T_floating_point auto t1, const T_floating_point auto t2){
        return t1+t2;
    }
    T_floating_point auto func_16_5(const T_floating_point auto t1, const T_floating_point auto t2){
        //return int{t1+t2};//error: deduced return type does not satisfy placeholder constraints
        return double{t1+t2};
    }

    auto func_16_6(const T_floating_point auto t1, const T_floating_point auto t2){
        return int{t1+t2};
    }

    auto func_16(){
        //cout << func_16_1(1,2) << endl;//error: no matching function for call to ‘func_16_1(int, int)’
        cout << func_16_1(1.,2.) << endl;//3

        //cout << func_16_2(1,2) << endl;//error: no matching function for call to ‘func_16_2(int, int)’
        cout << func_16_2(1.,2.) << endl;//3

        //cout << func_16_3(1,2) << endl;//error: no matching function for call to ‘func_16_3(int, int)’
        cout << func_16_3(1.,2.) << endl;//3
        //cout << func_16_3(1.,2.f) << endl;// error: no matching function for call to ‘func_16_3(double, float)’


        //cout << func_16_4(1,2) << endl;//error: no matching function for call to ‘func_16_4(int, int)’
        cout << func_16_4(1.,3.) << endl;//4
        cout << func_16_4(1.,3.f) << endl;//4

        cout << func_16_5(1.,3.f) << endl;//4

        T_floating_point auto t5 = func_16_5(1.,2.f);
        //T_floating_point auto t6 = func_16_6(1.,2.f);//error: deduced initializer does not satisfy placeholder constraints
        
        const T_floating_point auto t7 = func_16_5(1.,2.f);
        //T_floating_point const auto t8 = func_16_5(1.,2.f);//error: expected ‘auto’ or ‘decltype(auto)’ after ‘T_floating_point’
        T_floating_point auto const t9 = func_16_5(1.,2.f);
        //T_floating_point auto  t10 const = func_16_5(1.,2.f);// error: missing template arguments before ‘auto’

        
    }

    auto func_15(){
        [](const std::set<int>& iset){return iset.count(4)>0;};
        [](const std::multiset<int>& iset){return iset.find(4)!= iset.end();};
        [](const std::multiset<int>& iset){return iset.contains(4);};
    }

    // gcc 12.1
    // constexpr auto func_14_2_getVal(){
    //     return std::vector<int>{};
    // }
    // constexpr auto func_14_2_getSize(){
    //     return func_14_2_getVal().size();
    // }
    // template<std::size_t Size>
    // constexpr auto func_14_2_data(){
    //     auto value = func_14_2_getVal();
    //     std::array<int, Size> data;
    //     std::copy(begin(value), end(value), begin(data.begin()), end(data.end()));
    //     return data;
    // }

    constexpr auto func_14_1(){
        int* i = new int{};
        delete i;
        // the allocated memory must be freed in the constexpr context.
        
        //return i;//error: ‘Basic::func_14_1()’ is not a constant expression because it refers to a result of ‘operator new’
        //return *i;//error: ‘Basic::func_14_1()’ is not a constant expression because allocated storage has not been deallocated
        return 2;
    }

    auto func_14(){
        constexpr auto val = func_14_1();

        //constexpr auto size = func_14_2_getSize();
        //constexpr auto value = func_14_2_data<size>();
    }



    // tested in https://godbolt.org/ the 
    constexpr auto func_13_1(auto data){
        std::sort(begin(data), end(data));
        return data;
    }
    constexpr auto func_13_2(){
        constexpr auto ss = func_13_1(std::array{1,3,2,4});
        static_assert(std::is_sorted(begin(ss), end(ss)));
        return ss;
    }
    auto func_13(){
        for(auto i:func_13_2()){
            cout <<  i << ", ";
        }
    }

    auto func_12(){
        struct A{
        };
        
        struct B1_1: A{
            int i = 1;
            //[[no_unique_address]] A _;
            A _;
        };

        struct B1_2: A{
            int i = 1;
            [[no_unique_address]] A _;
        };

        struct B2: A{
            int i = 1;//4
        };

        struct B3_1{
            int i = 1;
            [[no_unique_address]] A _;//4
        };

        struct B3_2{
            int i = 1;
            A _;
        };


        cout << sizeof(B1_1) << endl;
        cout << sizeof(B1_2) << endl;
        cout << sizeof(B2) << endl;
        cout << sizeof(B3_1) << endl;
        cout << sizeof(B3_2) << endl;

    }

    auto func_11(){
        struct Data{
            int i{},j{};
            auto operator<=>(const Data&)const = default;
            //bool operator<(const Data& iD)const{ return i< iD.i;}
        };

        std::set<Data> d;
        d.insert({1,2});

        int a[3]={21,2,3};
        int b[2] = {4,5};
        cout << (2+b[1])[a-1] << endl;
        cout << (2)[a-1] << endl;
    }

    // parameter pack expansion
    template<typename C, typename... Args>
    auto bind_v(C ic, Args... args){
        //return [=](){
        return [_ic = std::move(ic), ..._args = std::move(args)](){
            return _ic(_args...);
        };
    }

    auto func_10(){
        auto l = [](int i, int j,int k){return i+j+k;};
        const auto bound1 = bind_v(l, 2,3, 4);
        cout << bound1() << endl;

        auto f2 = std::bind_front(l, 2,3);
        cout << f2(4) << endl;



    }

    auto func_9(){
        struct S{
            // in c++17, the bug is, with "S() = delete",  S still can be created with {1,2} or {.i=2}
            //S() = delete;//error: no matching constructor for initialization of 'S'
            int i, j;
        };

        S s{1,2};
    }



    auto func_8( std::vector<int> vec={1,2,3,5,5,6}){
       
        // old-style
        //vec.erase(std::remove(vec.begin(),vec.end(), 5));
        
        std::erase(vec, 10);//new erase: move to the end + erase
        // the erase operates ont the whole comtainer, like vector, list, etc...

    }


    constexpr double func_7_2(double angle){
        if(std::is_constant_evaluated()){
            return 5.;//do the slow things that doesn't rely on inline assembly
        }else{
            return 6.;// to the fast things that dose use inline assembly
        }
    }

    constexpr auto func_7_1(){
        struct S{
            [[nodiscard]] constexpr virtual int f()const = 0;
        };

        struct S1 : public S{
            [[nodiscard]] constexpr virtual int f()const override{
                return 1;
            }
        };
        struct S2 : public S{
            [[nodiscard]] constexpr virtual int f()const override{
                return 2;
            }
        };

        constexpr auto l = []{
            const S1 s1,s2,s3;
            const S2 s4,s5;
            const std::array<const S*,5> data{&s1,&s2,&s3,&s4,&s5};
            int sum = 0;
            for(const auto* elem: data){
                sum +=elem->f();
            }
            return sum;
        };

        constexpr auto ll = l();
        return ll;
     
    }
    auto func_7(){
        
        std::cout << func_7_1() << std::endl;//7

        auto z2 = func_7_2(1.);std::cout << z2 << std::endl;//6
        constexpr auto z3 = func_7_2(1.);std::cout << z3 << std::endl;//5
    }

    auto func_6(){
        struct S{
            std::string key, val;
        };

        std::set<S, decltype([](const auto&l, const auto&r){
            return l.key < r.key;
        }
        )
        > mySet;
    }


    auto func_5(){
        auto l = []{};
        auto m = l;
        m();
        decltype(l) ddl;
        decltype([]{}) ddl2;

        // warning: 'fopen' is deprecated: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS.
        // auto myDeleter = [](FILE*f){fclose(f);};
        // auto file=std::unique_ptr<FILE, decltype(myDeleter)>(
        //     fopen("TestTxt.txt", "w"), myDeleter
        // );

        // lambda has default constructor
        // auto file=std::unique_ptr<FILE, decltype([](FILE*f){fclose(f);})>(
        //     fopen("TestTxt.txt", "w")
        // );

    }

    auto func_4(){
        // why don't more standard library utilities use Auto return types, they say its not as good for spin a friendliness.

        auto l = [](const auto& p){ 
            std::cout << std::to_address(p) << "\n";
        };

        // heap: address big -> small; stack upwards
        if(auto sp = std::make_unique<int>(1)){
            l(sp);//0000023FDED9FFB0
            int x{2};
            l(&x);//000000411E8FFBA0
        }
        if(auto sp = std::make_unique<int>(2)){
            l(sp);//0000023FDED9FF10
            int x{3};
            l(&x);//000000411E8FFB88
        }

        std::vector<int> vec{1,2,3};
        l(vec.begin());//0000023FDED9E1B0
        l(vec.begin()+1);//0000023FDED9E1B4

    }


    auto func_3(){

        // we tested -O3, cannot be optimized to "mov eax,8"
        std::array data{1,2,3};
        auto total{0};
        for(std::size_t p = 0; const auto& c:data){
            total += (c*p++);
        }
        std::cout << total << std::endl;


        struct S{
            std::array<int, 4> data{1,2,3,4};
            const auto& get(){return data;}
        };
        auto getS =[]{return S{};};
        auto total_2{0};
        // here the nested calls may cause lifetime issures. But with clang c++2b, it works allright.
        for(std::size_t p = 0; const auto& c:getS().get()){
            total_2 += (c*p++);
        }
        std::cout << total_2 << std::endl;

        auto total_3{0};std::size_t p = 0;
        // However, only one ";" is supported in for
        for(auto s = getS();  const auto& c:s.get()){
        //for(auto s = getS(); std::size_t p = 0; const auto& c:s.get()){//error: expected expression
            total_3 += (c*p++);
        }
        std::cout << total_3 << std::endl;

    }


    
    auto func_2(){// template-like lambda
        auto l = []<typename T1, typename T2>(T1 t1, auto t2, 
        const std::vector<T2>& ivec){
            std::cout << t1 << " " << t2 << ivec.size() << "\n" << endl;
        };

        l(20220712, "hi", std::vector{1,2,3});
        //l(20220712, "hi", {1,2,3});//no matching function for call to object of type '(lambda  l )'

    }


    // struct S_func_1{
    //     static auto s_dd;//error: declaration of variable 's_dd' with deduced type 'auto' requires an initializer
    // };auto S_func_1::s_dd = 2*3;

    auto func_1(){//field designators

        struct S{
            //auto dd;//error: 'auto' not allowed in non-static struct member
            //static auto s_dd;//error: static data member 's_dd' not allowed in local struct 'S'
            int ii:3 = 0;
            unsigned int i;
            float j{};
            double d;
            //S():d(1.),i(2){}// The constructor disables the field designators
        };

        //S s1{i:1,d:3.2};//warning: use of GNU old-style field designator extension [-Wgnu-designator]
        S s2{.i=1,.j=2.};std::cout << s2.d << std::endl;
        
        S s3{.j = 2.};std::cout << s3.j << std::endl;
        S s4{.j = 2};std::cout << s4.j << std::endl;

        //S s4{.j = 3., .i=11};std::cout << s4.j << std::endl;//warning: ISO C++ requires field designators to be specified in declaration order;

        //S s5{.i=-1,.j=2.};std::cout << s5.d << std::endl;//error: constant expression evaluates to -1 which cannot be narrowed to type 'unsigned int'

        [](S is){
            cout << is.d << endl;
        }({.d = 5});

        auto s6 = S{
            .i = 6,
            //.i = 2222,//warning: initializer overrides prior initialization of this subobject
            .j = []{return 66;}()
        };std::cout << s6.i << ", " << s6.j <<  std::endl;
        
    }
}